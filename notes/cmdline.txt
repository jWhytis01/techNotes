    3  nano
    9  sudo ss -lpt
   24  sudo systemctl status
   26  # There is no history on this device yet
   28  #
   29  # I'm doing an exersise in user managment now.
   30  #
   31  file etc/shadow
   32  id - gets current user id
   33  > foo.txt - creates foo
   34  cd ~ - ~ goes home
   35  > foo.txt - same a touch ...
   36  less /etc/passwd
   37  less /etc/group
   41  man ls
   42  ls
   43  ls -l
   44  ls -la
   45  ls -laF
   46  man ls
   47  ls --file-type
   48  ls -al --file-type
   51  chmod 600 foo.txt
   55  umask - sets the default bit Mask for file permissions. The defaultis read and write.  So a mask of 0000 produces 0666 ?
   56  umask 0000
   62  script - starts a capture of history that can be replayedt
   64  # Here is a review of commands
   65  date - give date, has options
   66  cal - a visual calendar in week format
   67  sudo apt install ncal
   68  cal
   69  # find free space on disk
   70  df
   71  # end a terminal session with exit
   72  # Linux maintains 6 virtual sessions.  They can be accessed with ctl+alt+f1-6
   73  #pwd - print working dir
   74  pwd
   75  #cd - change directory
   76  cd ..
   77  cd ~
   78  ls
   79  #list directory often uses -la
   80  # it is possible to use absolute or relative path names
   81  # relative path names use ./
   82  ls ./
   83  cd /usr
   84  cd ~
Next one is interesting as it lets you spesify user name of home directory
   85  cd ~ubunto
   86  cd ..
   87  ls
   88  cd ~ubuntu
   96  # you can get 2 directorydirectorâ€™s  listings at once
   97  ls ~ /usr
   98  ls -la
   99  # -l gives list with details and a gives all including hidden.
  100  ls -lt
  101  # in the file list it's permissions, hard links, user, group, Size in bytes, mod date, filename
  102  # file gives file type
  103  file *
  104  # this is very useful!  Love File!
  105  # less is a pager - q quits
  106  less foo.txt
  107  # less replaces the less functional "more"
  108  /dev
  109  ls /dev
  110  # /dev is a list of system devices
  111  cd /etc
  112  ls
  113  # etc contains system wide config files including passwd and group
  114  # /etc/crontab controls when jobs will rung
  115  # /etc/fstab devices and mount points
  116  # /etc/passwd list of user accounts
  117  cd /home
  118  ls
  119  # /home/ contains user files ~
  120  # /lib - like dlls
  121  # lost+found - system failure last chance recovery area
  122  # /media mount points for devices like cd roms
  123  # /mnt older -removable devices mounted manually
  124  # /opt install optional software.
  125  cd /opt
  127  cd /proc
  131  less mounts
  133  # processes the kernal is running
  135  sudo cd /root
  136  cd ..
  138  sudo cd root
  139  cd root
  140  #home directory of the root account 
  146  less /etc/group
  147  cd /sbin
  149  # /sbin system commands - ie reboot
  150  cd /tmp
  152  # /tmp temp install files and the like
  153  cd /usr
  155  # shared progrmas for all users
  156  cd local
  158  # /usr/local compiled programs put here
  160  cd /share
  162  # /usr/share default directory for all shared data from /usr/bin
  163  cd ..
  167  # /var databases, spool files, logs
  168  cd log
  170  cd journal/
  172  tail 9c8fb5e73a559779ecdf1ce5a7970931/
  173  cd 9c8fb5e73a559779ecdf1ce5a7970931/
  175  tail system.journal 
  
  181  # Next up cp!
  182  # cp -u *.html destination
  183  # this copies all non existent or newer files to the spesified directory
  184  #wildcards, *, ?, [], [!xx] [[:class:]]
  185  # class [:alnum:] [:alpha:] [:digit:]
  186  # ex BACKUP.[0-9][0-9][0-9]
  187  # ex [[:upper:]]* begins with upper case character
  188  # these work in the file manager
 
 189  # mkdir - makes directories
  190  # cp - big note! -a says keep the attributes of the files being copied.  If they don't have -a then they take on the copiers creds!
  191  # cp -i - prompt before overwriting
  192  # a is for arhive, give me a copy as is.
  194  mkdir zplay
  195  cd zplay/
  196  mkdir realThing
  197  mkdir /realthing/fiveFiles{1..5}
  198  mkdir realthing/fiveFiles{1..5}
  200  mkdir realThing/fiveFiles{1..5}
  201  ls realThing/
  202  touch realThing/fiveFiles{1..5}/txtfile_{1..100}.txt
  204  cd realThing/
  205  ls -lar
  210  # way cool cp -a recursivily copies everything!  better than -r as it preserves permissions!
  211  # -v gives more info
  214  mv rt rtr
  
  221  # this is becoming a playground!
  222  # rember expansion matters
  223  mv rtr/fiveFiles1 rtr/ff001 rtr/fiveFiles2 rtr/ff002
  224  ls rtr
  225  mv rtr/fiveFiles{1..5} rtr/ff00{1..5}
  226  ls rtr
  227  mv rtr/fiveFiles1 ff001
  228  ls
  229  ls rtr/
  230  ls ff001/
  231  # ln create link
  233  rm -r ff001/
  235  rm -r rtr/
  
# Here we are creating links to files. ln
TODO : Clarify how links work
  238  ln realThing/fiveFiles{1..5}/txtfile_1.txt ff{1..5}_1.txt
  240  ln ff_1_{1..5}.txt  realThing/fiveFiles{1..5}/txtfile_1.txt
  241  echo ln ff_1_{1..5}.txt  realThing/fiveFiles{1..5}/txtfile_1.txt
  
# This is an example of using echo to understand how a command will expand.  Notice there are real world consequences to making a one space mistake

242  echo rm
  243  echo rm * .html
  245  echo cd ..
  
the echo cd .. command above does not do much
if you want to go up two directoris you can do this or create and alias to do it.
249  cd ..; cd ..
  251  cd admin_jason/
  252  ls
  253  cd zplay/
  254  ls
  255  echo ln ff_1_{1..5}.txt  realThing/fiveFiles{1..5}/txtfile_1.txt
  256  ln realThing/fiveFiles{1..5}/txtfile_1.txt ff_1_{1..5}.txt
  257  echo ln realThing/fiveFiles{1..5}/txtfile_1.txt ff_1_{1..5}.txt
  258  clear
  

260  # Chapter 5 - Commands
  261  # 4 types executable, shell built in, shell function, alias
  262  type type

# because my machine did not have xwindows this was largely a futile expersize.
  263  #npm install -g clipboard-cli
  264  npm install -g clipboard-cli
  265  apt install clipboard-cli
  266  sudo apt install clipboard-cli
  267  apt-get install xclip
  268  sudo apt-get install xclip
  269  echo {1..100} | xclip
  270  sudo apt update -yy
  271  sudo apt install i3 -yy
  272  echo {1..100} | xclip
  273  type type
  274  type ls

  275  # type shows one of 4 types
  276  # give alias info
  277  which ls
  278  which python
  279  which python3
  280  which docker
  281  which xwindows
  282  which x11
  283  # looks up executables in path

  284  which cd
  285  which gcloud
  286  help cd
  287  mkdir --help
  288  man mkdir

  289  # man has 8 chapter sections.  Defaults to 1: User Commands, 8 is sys admin commands
  290  man 8 mkdir

  291  # we also have a what can i do? command: apropos
  292  apropos file
  293  apropos file | less
  294  ls
  295  chksum theLog.txt
  296  cksum theLog.txt 

  297  help zcat
  298  man zcat
  299  whatis zcat

  300  # apropos and whatis use the same on liner from the an pages
  301  # so far we have help XXX, XXX -help, XXX --help, whichis, whatis, apropos

  302  # and now info
  303  info mkdir
  304  # this is really powerful
  305  # U takes us up, enter lets us follow a link.  There are more commands
  306  info docker
  307  man docker
  315  # alies name='string'
  notice the name string thing can not have spaces
  316  # unalias name
  
  327  # > redirects overwritng file
  328  # >> redirects adding to file
  329  "Hi There" >> 3filelist.txt 
  330  echo "Hi There" >> 3filelist.txt 
  331  less 3filelist.txt 
  332  # this brings up single vs double quotes
  333  # warning - if a > comand fails the file si overwritten with nothing!
  334  # commands typicly have three communication channels standard in, standard out, error out
  335  ls > 3filelist.txt 
  336  less 3filelist.txt 
  337  ls 1> 3filelist.txt 
  338  less 3filelist.txt 

  339  # above shows redirection of stdout implicity and explicity
  340  lsx 2> 3filelist.txt 
  341  less 3filelist.txt 
  342  # to push both stdout and stderruse & in shell
  343  lsx &> 3filelist.txt 
  344  less 3filelist.txt 
  345  # redirecing to dev/null throws away output

  346  ls
  347  cat foo.txt
  348  cat 3filelist.txt 
  349  cat theLog.txt 
# I'm just playing here but note cat can be fed multiples
  350  cat theLog.txt 3filelist.txt 
  351  cat theLog.txt 
  352  cat theLog.txt 3filelist.txt > fullLog.txt
  353  cat fullLog.txt 
  354  ls

  355  # cat cal also be used for input
  356  cat > saveWhatIType.txt
  357  cat saveWhatIType.txt 
  358  cat > doMe.sh

Here i crete a bash file on the fly using a redirect of cat.
Cat just uses a blank for it's standard in
Other programs use a - dash or @ or whatever.
Some swith between standard in and out based on context

  359  chmod 777 doMe.sh 
  360  ./doMe.sh
  361  cat > doMe.sh
  362  ./doMe.sh
  363  nano doMe.sh 
  364  ./doMe.sh
  365  nano doMe.sh 
  366  ./doMe.sh

  367  # bash scripts can't use aliases!
  368  # by default cat copies stdin tostdout
  369  # | can take output from one andtreat is as input to the next
  370  # and filters are often used in pipes
  371  ls /bin /usr/bin | sort | uniq |less
  372  ls

  373  wc 3filelist.txt 
  374  # wc prints lines, words and bytes in a file
  375  # grep lets you really filter
  376  less 3
  377  less 3filelist.txt 
  378  grep lex 3filelist.txt 
  379  man mkdir | grep mkdir
  380  info mkdir | grep mkdir
  381  info mkdir chmod
  382  info mkdir | grep chmod
  383  info mkdir | grep -B 2 -A2 chmod
  384  info mkdir | grep -B 3 -A 3 chmo

  385  # note the grep before and after

  386  # head and tail print first and last part
  387  # tail can be active with a log, tail -f /var/log/messages
  388  # close with ctl-c
  389  tail -f /var/log/messages
  390  tail -f /var/log/message
  391  sudo tail -f /var/log/messages
  392  cd /var/log
  394  tail -f syslog
  399  /bin
  400  ~./doMe.sh
  402  ~/doMe.sh
  
  404  # tee sends current ouput to a file and hands it down the pipleline
  410  ls /usr/bin | grep zip | tee grepzip.txt | grep pre | tee pregrepzip.txt
  412  cat pregrepzip.txt grepzip.txt 
  
  414  sudo -l
  415  #sudo -l lists permissions
  
  416  # chown [owner][:[group]]
  417  # exampes bob bob:users :admins bob: 
  418  # self expanitory except bob: this changes the group to bob's login group
  419  # setting the sticky bit for a group on the file folder ensures the group on the files created within will stick
  420  whatis ch
  422  apropos group | less
  423  group
  424  groups
  428  sudo addgroup my_music
  430  mkdir my_music
  433  chown :my_music my_music
  434  sudo chown :my_music my_music
  437  chmod g+s my_music
  439  sudo chmod g+s my_music
  441  touch my_music/thesong.mp3
  442  ls -l my_music/
  
  443  ####################
  444  # Processes Chapter
  445  ps - process list
  446  top - live process list - task manager
  447  jobs - list of jobs (by session?)
  448  bg - backgound
  449  # jobs - list ;  bg job - puts job in background 
  450  # fg - puts job in forground
  451  # kill - kills one job, need number
  452  # killall kills all processes of a kind
  453  # shutdown - reboots the system
  454  ps -x
  455  # shows all processes
  456  ps x

  457  # Stat is state, s - sleep, r - running, d - waiting for io, t stopped , z - zombie, < high priority , n - low priority

  458  # another option
  459  ps aux
  460  ps aux | grep "I"
  462  nano &
  463  # I started running nano as a background process
  464  jobs
  465  ps
  466  # about to switch to it
  467  fg %1
  468  nano
  469  # ctrl-z pushes a process to the backgroud.
  470  fg nano
  471  bg %1
  472  jobs
  473  kill nano
  474  kill 1
  475  sudo kill 1
  476  jobs
  477  sudo kill %1
  478  ps
  479  kill 29879
  480  ps
  481  sudo kill 29879
  482  ps
  483  sudo kill 9 29879
  484  ps
  485  sudo kill -9 29879
  486  ps
  487  # that worked!
  488  nano &
  
# the above was fun with processes
# below is more detail
  489  ps
  490  ps aux | grep nano
  491  pstree
  492  # outputs a process tree
 
   493  vmstat
  494  # system info
  495  xload
  496  # xload shows system load graph over time in windows environment
  497  tload
 
 498  ########
  499  # that is the end of notes for part one

####################################
# WOOT
####################################

# here  we get into packaging utilities

# All this works for Debian / Ubuntu
# The Mac has a whole different stack. :-(
  
  674  dpkg --search "/usr/bin/vim"
  675  ls /usr/bin/v*
  678  dpkg --search /usr/bin/vim.basic
  680  dpkg --list | grep vim

  681  apt-get install apt-file
  682  sudo apt-get install apt-file
  683  apt-file update
  684  sudo apt-file update

  685  apt-file list docker-ce
  686  # this is gold!

  687  dpkg -L docker-ce
  688  # this provides a tree.
  689  # https://manpages.ubuntu.com/manpages/xenial/en/man1/dpkg-query.1.html

  690  sudo apt-get install dpkg-query
  691  sudo apt install dpkg-query

  692  # can review further https://manpages.ubuntu.com/manpages/focal/en/man1/dpkg-query.1.html


# The devices stuff work on Mac with an additional tool
  693  # Devices
  694  # mount is the command for adding a devce
  695  less /etc/fstab
  696  # device list
  697  # to see a list of filesytems type mount
  698  sudo mount
  699  # a mount point is simply a directory somewhere in the file system
  700  cd /dev
  701  ls
  702  # these are all devices on the system
  705  traceroute slashdot.org
  706  whereis tracert
  707  whatis tracert
  708  sudo apt-get update
  709  apt-get search traceroute
  710  man apt-get
  780  ps
  781  netstat -ie
  782  netstat -r
  783  ftp fileserver
  784  ping fileserver
  785  ping google.com
  786  wget http://linuxcommand.org/index.php => 'index.php'
  788  less index.php
  790  less index.php.1
  
791  sudo apt-get install html2text
  792  ls
  793  mv index.php.1 linuxcommand.org.html
  794  html2text linuxcommand.org.html | less

  795  dpkg
  796  man dpkg
  797  dpkg --list
  798  dpkg --list | grep html

  799  apropos package
  805  sudo mkdir ajMyBack
  807  cd admin_jason/
  
I took a little digresion into making a backup

808  cp -a * ../ajMyBack
  809  sudo cp -a * ../ajMyBack
cd ..  
821  sudo chown admin_jason:admin_jason ajMyBack
  823  cd ajMyBack/
  828  rm -r ajMyBack/
  829  sudo rm -r ajMyBack/

Cleaned it up and went back to book

  834  dpkg --list | grep ssh
  
for some reason added my group to sudo...
846  addgroup sudo jwhiteis
  847  sudo addgroup sudo jwhiteis
  848  sudo addgroup jwhiteis sudo

and  simplified my propmpt
  855  echo $PS1 > shell.txt
  857  vim shell.txt 
  869  PS1=$(cat shell.txt)
  
This power is cool.  Need to revisit with an xwindows installed
886  # you can use ssh as a vpn if yourun xload thru an ssh session.  At least in theory
  887  # I'm doing ssh thru googles api.I beleive they are using openSSH
  888  # scp jason-dev:shell.txt .
  889  sudo scp jason-dev:shell.txt 

hitting the two ways to see environmental vars here.  Set is a more complete list than printenv
  890  printenv
  891  set
  892  set | less
  893  history | grep PS1
  894  PS1=$(cat shell.txt)


  895  # Chapter 17
  896  # locate - find files
 
 897  locate bin/zip
  898  # we look in bin because that is where we find program files.  WE use zip to find zip.
  899  # This is dependent on haveing a database built tracking this stuff

  900  locate zip
  901  locate zip | grep bin
  906  whereis locate
  
I went into severla digresions here
the alternatives is esentially a way to alias programs
I'm wondeing if it is a best practice to put everything installed here.

https://refspecs.linuxfoundation.org/FHS_3.0/fhs-3.0.pdf

Is there such a thing as the registry on linux? No, config is in the /etc directory and a users home directory.  Other places are possible but this is where to start.

907  ls -la /usr/bin/locate
  908  ls -la /etc/alternatives/
  909  ls -la /etc/alternatives/ | less
  910  very cool
  911  # very cool
  912  # the /etc/alternatives directory holds a bunch of symolic links to obsficate the use of diferent programs for similar comands
 
I took a side trip into jobs here.
  916  apropos cron
  917  man crontab
  918  crontab -l
  922  sudo crontab -l -u root
Strange that i had to do root  

cron jobs update the db - may want to do manual
923  sudo updatedb

  924  # this updates the locate db
  925  # locate can be out of date!

  926  # does locate have a date added and date updated?
  927  find ~
  928  # find will find files by more than just name
  931  find ~ | wc -l
 
 932  # find uses tools called tests, actions, options
  933  find ~ -type d | wc -l
  934  find ~ -type d 
  935  find ~ -type t
  936  find ~ -type text
  937  find ~ -type f
  938  find ~ -type l
  939  find ~ -type f -name "*.JPG" -size +1M 

  940  # cmin - files modifid exactly, before or after n
  941  touch newcmin.txt
  942  find -cmin -5
  943  # min is short for minutes

  944  # cnewer - newer tha  spesified file
  945  find -cnewer shell.txt
  946  # note the above are modified times, not created times
  947  # ctime older/PIT?newer than time

  949  fine -ctime -12
  950  find -ctime -12
  951  find -ctime +12
  952  # second was a much shoter list

  953  find -empty
  954  #finds empty files or diectories
  
955  find -group music
  956  find -group admin_jason

  957  # wow! am i glad i kept reading
  958  # iname - case insensitive name
  959  # wild cards are also case insensitive
  960  find -iname myfile.txt
  965  find -iname "cmdline*"
  966  cd ~
  968  ls -lai /etc/alternatives/ | tail
  970  ls -lai /usr/bin/i3
  971  find -inode 70032
  972  # whoops, that inum
  973  find -inum 70032
  974  # must be a hard link
  975  find -type l
  976  cd ..
  977  find -type l
  978  find -type l -ll
  979  find -type l -l
  980  find -mmin 45 
  981  sudo find -mmin 45 
  982  cd ~
  983  # going back to home - find is relative to the directory
  984  history | grep newer
  985  # each thing is it's own thing
  986  find newer shell.txt
  987  find -newer shell.txt
  988  # find files that do not have an active user.
  989  find -nouser
  990  find -nogroup
  991  touch nousergroup
 1001  sudo adduser clown

this adds the user and group 
1002  chown clown:clown nousergroup 
 1003  sudo chown clown:clown nousergroup 
 1011  sudo deluser clown
 1013  sudo delgroup clown
 1015  find -nouser
 1016  # that did it!
 1017  ## Next command
 1018  # find -perm permissions aka mode
 1019  # find everything that is fired by everyone
 1020  find -perm 777
 1021  man find | grep -B4 -A4 hardlink
 1022  man find | grep -B4 -A4 link
 
1029  cd .cache/
 1030  ls
 1031  cd ..
 1032  # -samefile looks for hard links
 1033  # -size looks for files of size
 1034  -type c  files/directories of type c
 1035  # - user matches userid
 1036  # the above were tests
 1037  # Operators are next
 1044  find ~ \( -type f -not -perm 0600 \) -or \(  -type d -not -perm 0700 \)
 1045  # spaces are very important
 1046  # -and, -or, -not and parens () group things
 1047  # note that the parens need to be escaped so they are not interpried by shell expansion.  the find command understands this

 1048  # Actions
 1049  # so we have tests and can apply operators to the results.
 1050  # now we need to do something.
 1051  -delete delete the file, -ls perform ls -dils, -print default - is full path, -quit quit at first match

There are different ways to accomplish these things, ls piping and core os commands rm for delte, come to mind. 

1055  touch mybak.bak
 1056  ls *.bak
 1057  find ~ -type f -name "*.bak" -delete
 1058  ls *.bak

 1059  # before using delete use print to see what will happen
 1060  # new idea on whatif - does it just replace delete with print
 1061  whatif
 1062  # order of tests is important!
 1063  # you can also build your own actions.
 1064  # -exec actions
 1065  # -exec rm '{}' ';'
 1066  # the above works like the delete command
 1067  # {} the resultset of paths, the semi colin ends it.  I wonder if you can do multiples?
 1068  touch foo1 foo2 foo3
 1069  ls foo
 1070  ls foo*
 1071  find ~ -type f -name "foo*" -ok ls -l '{}' ';'
 1072  # can i inject feedback with the -ok command?  it is what makes this interactive
 1073  # the semi drives this to execute one at a time
 1074  # you can use a plus + to add them together
 1075  find ~ -type f -name "foo*" -ok ls -l '{}' +
 1076  find ~ -type f -name "foo*" ls -l '{}' +
 1077  find ~ -type f -name "foo*" -exec ls -l '{}' +
 1078  # xargs can do the same thing
 1079  # and a pipe!
 1080  find ~ -type f -name 'foo*' -print | xargs ls -l
 1081  # xargs applies a command to a piped in list
 1082  echo find ~ -type f -name 'foo*' -print | xargs ls -l
 1083  # commands can get too long
 1084  xargs --show-limits
 1085  man xargs
 1086  # deal with spaces
 1087  # xargs --null ls -l
 1088  ls
 1089  mkdir playground/dir-{00{1..9},0{10..99},100}
 1090  mkdir -p playground/dir-{00{1..9},0{10..99},100}
 1091  cd playground/
 1092  ls
 1093  cd ..
 1094  touch playground/dir-{00{1..9},0{10..99},100}/file-{A..Z}
 1095  tree playground
 1096  # makedir -p is for parent as in make the parent!
 1097  find playground -type f -name 'file-A'
 1098  find playground -type f -name 'file-A' | sort
 1099  find playground -type f -name 'file-A' | sort | wc -l
 1100  touch playground/timestamp

 1101  # create a timestamp reference point
 1102  # stat - more than ls
 1103  stat playground/timestamp 
 1104  find playground -type f -name 'file-B' -exec touch '{}' ';'
 1105  # that gives us changes after our timestamp
 1106  find playground -type f -newer playground/timestamp 
 1107  find playground \( -type f -not -perm 0600 \) -or \( -type d -not -perm 0700 \)
 1108  find playground \( -type f -not -perm 0600 \) -or \( -type d -not -perm 0700 \) | sort
 1109  find playground \( -type f -not -perm 0600 -exec chmod 0600 '{}' ';'  \) -or \( -type d -not -perm 0700 -exec chmod 0700 '{}' ';' \) 
 1110  find playground \( -type f -not -perm 0600 \) -or \( -type d -not -perm 0700 \) | sort
 1111  # the bad permisions for files and directories are different and are thus updated within the parens


 1112  ###################
 1113  # Options
 1114  # finer grained control
 1115  # -depth process directories before files, -maxdepth levels - max levels down, mindepth levels - go down at least levels then apply tests, -mount - stay local, don't crossmount points, -noleaf - use with windows/dos or cd roms

no examples of the above


a bit of housekeeping here
 1122  apt list --upgradeable

 1123  ###############
 1124  # Backup
 1125  # gzip: expand/compress files, bzip2 block sorting file compressor. tar tape archiving utility, zip package and compress files, rsync - remote file and directory synchronizations

We have a few files called foo, foo1, foo2 
Create a file with some contents...

1131  echo {A..Z}_{1..1000}_{x..z} > bigfile.txt
 1134  echo {A..Z}_{1..1000}_{x..z} | sort  > bigfile.txt
 1135  less bigfile.txt 
 1137  gzip foo*
 1139  gzip foo*
 1140  gzip -d foo*
 1142  gzip -c bigfile.txt 
 1144  gzip bigfile.txt 
 1147  gzip -d bigfile.txt 
 
-- c sends output to stdout - useful for sshing a file from one server to another
-- d is decomress.  o

 1150  cp bigfile.txt bigfile2.txt 
 1151  cat bigfile.txt bigfile2.txt > bigfile3.txt
 1153  gzip bigfile*
 

1156  gzip -c bigfile.txt > bf.gz
 1158  rm bf.gz 
 1159  gzip -d  big*
 1161  gzip -c bigfile.txt > bf.gz
 

Stat is a more in depth look at a file
It includes blocks occupied, blocks used etc

1163  stat bf.gz 
 1164  gzip -d bf.gz
 1166  less bf
 1167  # cool! redirect the output ofthezip file does keep the original in place
 1168  # everything about unix is about winning

see the differnece between ls and stat
 1169  ls -l /etc
 1170  stat /etc
 1173  sudo ls /etc/sudoers.d
 1174  sudo ls -l /etc/sudoers.d


 1175  echo $((4096/2)/2)
 1176  ls -l /etc | gzip > foo.txt.gz
 1177  ls
 1178  less foo.txt.gz 
 1179  stat foo.txt.gz 
 1180  gzip -d foo.txt.gz 
 1181  stat foo.txt.gz 
 1182  stat foo.txt
 1183  # less will open zip files if asked
 
-- gunzip think g-un-zip
1184  # gunzip will also act as gzip -d
 1185  # gunzip expects the gz extension
 1187  gzip bigfile3.txt
 1189  gunzip bigfile3.txt
 1191  gzip bigfile3.txt
 1192  zcat bigfile3.txt.gz | less
 
1193  # zcat works like cat for zip files, like gunzip -c
 1194  # this is beautiful
 1195  # bzip2 - higher compression at the cost of speed 

tar - a great way to package files togehter

 1196  # .tar - uncomressed tape archive
 1197  # .tgz - compressed tape archive
 1198  tree playground/
 1199  tar cf playground.tar playground
 1201  # List contents of playground.tar
 1202  tar tf playground.tar
 1203  tar tvf playground.tar
 1204  # if the user performing the restore is not the super user the files will take on the current user's group:user
 1205  sudo mkdir foo
 1206  cd foo
 1209  sudo tar xf ../playground.tar
 1211  tree playground/
 1213  # pathnames are relative.  If you start at the root and want to restore from the root you must cd back to the root.
 1214  # you can also pluck files
 1217  mkdir foo2
 1218  mkdir fooo
 1219  cd fooo
 1222  sudo tar xf ../playground.tar playground/dir-100
 1224  cd playground/
 1226  ls dir-100/
 1229  sudo tar xf ../playground.tar playground/dir*/file-A
 1230  tree 
 1236  sudo tar xf ../playground.tar --wildcards 'playground/dir-*/file-A'
 1237  tree
 1238  # the quotes did the expansion
 1239  # using pipes - (dash) takes the place of the filename
 1240  # so tar is a way of bundling files.  Zip is a way of compressing tars
 1241  # zip - mostly for windows
 1242  # use -r for recursion



 1244  zip -r playground.zip playground
 1245  sudo apt install zip
 1246  zip -r playground.zip playground
 1248  cd foo
 1251  sudo rm -r playground/
 1254  sudo unzip ../playground.zip
 1256  sudo tree
 1260  unzip -l playground.zip
 1261  cd foo
 1263  sudo rm -r playground/
 1266  sudo unzip ../playground.zip playground/dir-087/file-Z
 1267  sudo tree
 1268  cd ..
 
1269  find playground -name "file-A" | zip -@ file-A.zip
 1270  # Ok, way cool.  Just like gzip we can use the sysin sysout as appropriate
 1271  # for zip it's -@ as the param
 1272  # note that tar can do network file copy where zip can not.  tar -c to pull output thru ssh
 1273  # zip will take file input on the fly
 1274  ls -l /etc/ | zip ls-etc.zip -
 1275  unzip -p ls-etc.zip | less

 1276  #################
 1277  # while we can create a timestamp file and coordinate file sync updates there is a utility just for this.
 1278  # remote to remote sync is not supported
 1279  # one or the other can be remote but not both
 1280  rm -rf foo/*
 1281  sudo rm -rf foo/*
 1282  ls
 1283  ls foo
 1284  ls -l playground
 1285  rsync -av playground foo
 1286  sudo rsync -av playground foo
 1287  ls foo
 1288  tree foo
 1289  # like copy cp -a makes an archive, recurising thru the directories and preserving user info
 1290  tree -v foo
 1291  man tree | grep -B4 -A4 verbose
 1292  rsync -av playground foo
 1293  # no files went - none needed to be updated
 1294  tree foo
 1295  tree -d foo
 1296  touch foo/playground/dir-001
 1297  touch foo/playground/dir-002/file-A
 1298  rsync -av playground foo
 1299  # and we could also use the URI serve
 1300  # This ends the archiving section.

And now into regex...

 1301  # grep stands for global regular expression print
 1302  # grep [options] regex [file..]
 1303  # -i ignore case, -v invert match, -c num of matches, -l print name of file containing a match, -L only print name of files, -n prefix matching lines with line numbers, -h for multifile searches supresses file names
 1305  mkdir regex
 1306  cd regex
 
I threw some text with names into these files

1307  cat > File001.txt
 1308  cat File001.txt 
 1309  cat > File002.txt
 1310  cat File*
 1311  cat > File003.txt
 1313  grep Sally File* 
 1314  grep sally File* 
 1315  grep -i sally File* 
 1316  grep -ic sally File* 
 1317  # prints zero for the file if empty
 1318  grep -il sally File* 
 1319  grep -iL sally File* 
 1320  # Capital L tells us if it had not occured
 1321  grep -in sally File* 
 1322  grep -ih sally File* 
 1323  # no file name
 1324  #
 1325  ls /bin >dbin.txt
 1326  ls /usr/bin >dub.txt
 1327  ls /sbin>dsbin.txt
 1328  ls /usr/sbin >dusbin.txt
 1329  ls
 1330  grep dzip d*
 1331  grep bzip d*
 1332  grep -L bzip d*
 1333  # regular expression meta characters
 1334  # ^ . [ ] { } - ? + ( ) | \
 1335  grep -h '.zip' d*.txt
 1336  # notice the search string is enclosed in quotes
 1337  # the . dot is any character. so the list is xzip
 1338  # anchors ^ line begin $ line end
 1339  grep -h '^zip' d*.txt
 1340  grep -h 'zip$' d*.txt
 1341  grep -h '^zip$' d*.txt
 1342  echo {a..z}{a..z}{a..z}
 1343  echo {a..z}{a..z}{a..z}{a..z}
 1344  echo {a..z}{a..z," "}{a..z}{a..z}
 1345  echo {a..z}{a..z}{a..z}{a..z," "}
 1346  echo {a..z}{a..z}{a..z}{a..z}
 1347  echo {a..z}{a..z}{a..z}{a..z} > bigtext.txt
 1348  ls -l
 1349  gre[ cow bigtext.txt 
 1350  grep cow bigtext.txt 
 1351  grep 'cow' bigtext.txt 
 1352  grep 'frogger' bigtext.txt 
 1353  echo {a..z}{a..z}{a..z}{a..z}[\n] > bigtext.txt
 1354  grep 'cow' bigtext.txt 
 1355  ls /usr/share/dict
 1356  # we can use this to solve crosswords
 1357  grep -i '^..j.r$' /usr/share/dict/words
 1358  # match bzip or gzip
 1359  grep -i '[bg]zip' d*
 1360  # caret gets a second use.  in brackets it is a negations
 1361  grep -i '[^bg]zip' d*; # find all that do not have b or g
 1362  # notice they did have to have something
 1363  # find something A-Z uppercase
 1364  grep -h '^[A-Z]' d*
 1365  grep -h '^[A-Za-z0-9]' d*
 1366  grep -hc '^[A-Za-z0-9]' d*
 1367  grep -hc '[]' d*; # if you want to match a dash do it first
 1368  grep -hc '[-]' d*; # if you want to match a dash do it first
 1369  grep -h '[-]' d*; # if you want to match a dash do it first
 1370  echo $LANG
 1371  # Enter POSIX character classes
 1372  # [:alnum:] All alpha numberics
 1373  # [:word:] Same as above + _
 1374  # [:alpha:] just alphabet
 1375  # and many more
 1376  # posix character classes can also be usedffor shell expansion
 1377  locale
 1378  # Fun fun
 1379  # two types of Regular Expresions
 1380  # BRE - Basic Regular expresions
 1381  # ERE - extended regular expressions
 1382  # BRE has ^ $ . [ ] *
 1383  # ERE has those and ( ) { } ? + |
 1384  # in BRE you can use some of ERE if you escape the characters \( \) \{ \}
 1385  # grep uses BRE by default but can be switched to ERE if -E is used
 1386  # the Balkanization - 1988 a time when many vendors tried to silo unix
 1387  ieee 1003 to the REscue
 1388  # !!
 1389  POSIX Portable Operating System Interface.
 1390  #######33
 1391  # So much for history
 1392  # Alternation - the ability to show the result of multiple regex expressions
 1393  echo "AAA" | grep AAA
 1394  echo "BBB" | grep AAA
 1395  # Alternation uses the verical pipe character
 1396  echo "AAA" | grep -E 'AAA|BBB'
 1397  echo "BBB" | grep -E 'AAA|BBB'
 1398  echo "CCC" | grep -E 'AAA|BBB'
 1399  echo "CCC" | grep -E 'AAA|BBB|CCC'
 1400  # we can use parens to enclose alternations
 1401  grep -Eh '^(bz|gz|zip' d*
 1402  grep -Eh '^(bz|gz|zip)' d*
 1403  # ? make the preceeding element optional
 1404  # \(?
 1405  # match a literal parens zero or one times
 1406  think phone numbers
 1407  cat > phonex
 1408  cat phonex 
 1409  PHONEX=$(cat phonex)
 1410  echo $PHONEX
 
I messed around with storing a command in a variable but don't think i ever got it working.

1411  echo "(555) 123" | $($PHONEX)
 1412  vi phonex
 1413  PHONEX=$(cat phonex)
 1414  echo $PHONEX
 1415  vi phonex
 1416  PHONEX=$(cat phonex)
 1417  echo $PHONEX
 1418  echo "(555) 123-1234" | $($PHONEX)
 1419  vi phonex
 1420  echo "(555) 123-1234" | $($PHONEX)
 1421  echo $PHONEX
 1422  vi phonex 
 1423  echo "(555) 123-1234" | $($PHONEX)
 1424  vi phonex 
 1425  PHONEX=$(cat phonex)
 1426  echo "(555) 123-1234" | $($PHONEX)
 1427  echo $PHONEX
 1428  echo "This works." | grep -E '[[:upper:]][[:upper:][:lower:]]*\.'
 1429  # not working but correct..
 1430  # + works like * but needs at least one characters
 1431  echo "This that" | grep -E '^([[:alpha:]]+ ?)+$'
 1432  echo "a b c" | grep -E '^([[:alpha:]]+ ?)+$'
 1433  echo "a b 9" | grep -E '^([[:alpha:]]+ ?)+$'
 1434  # no match
 1435  echo "abc d" | grep -E '^([[:alpha:]]+ ?)+$'
 1436  echo "abc d9f" | grep -E '^([[:alpha:]]+ ?)+$'
 1437  echo "abc  df" | grep -E '^([[:alpha:]]+ ?)+$'
 1438  # curly braces match an element a number of times
 1439  # matches preceeding {n} exactly n, {n,m} at least n but no more tham m, {n,} n or more, {,m} m or fewer
 1440  echo "(555) 123-1234" | grep -E '^(?[0-9]{3}\)? [0-9]{3}-[0-9]{4}$'
 1441  echo "(555) 123-1234" | grep -E '^\(?[0-9]{3}\)? [0-9]{3}-[0-9]{4}$'
 1442  echo "555 123-1234" | grep -E '^\(?[0-9]{3}\)? [0-9]{3}-[0-9]{4}$'
 1443  echo "5565 123-1234" | grep -E '^\(?[0-9]{3}\)? [0-9]{3}-[0-9]{4}$'
 1444  ls
 1445  less dbin.txt

This was huge!  Search all man1 pages.
you could do some coordination of man pages and which were available for which
using tree -d you can see the language related subdirectories.

 1446  cd /usr/share/man/man1

zgrep will seach compressed and uncompressed files
in the examples below it seaches in *gz files
 1447  zgrep -El 'regex|regular expression' *.gz
 1448  zgrep -El 'regex|regular expression' *.gz | less
 1449  zgrep -El 'regex|regular expression' *.gz | sort |less

 1450  man ptx


 1451  hitory | grep PS1
 1452  history | grep PS1
 1453  PS1=$(cat shell.txt)
 1454  # new friends: paste-merge lines of files, join-join lines of files, comm-compare two sorted file line by line
 1455  diff- compare files line by line
 1456  # diff- compare files line by line
 1457  # patch - apply a diff file to an original, tr - translate or delete charaters, sed stream editor of filterrng and transforming text, aspell - interactive spell checker
 1458  ls
 1459  rm -r foo*
 1460  sudo rm -r foo*
 1461  ls
 1462  history | grep PS1
 1463  PS1=$(cat shell.txt)
 1464  ls
 1465  cat > foo.txt
 1466  cat -A foo.txt 
 1467  less foo.txt
 1468  cat > foo.txt
 1469  cat foo.txt
 1470  cat -A foo.txt
 1471  cat > foo.txt
 1472  cat -A foo.txt
 1473  cat -ns foo.txt
 1474  cat -nsA foo.txt
 1475  cat -ns foo.txt
 1476  cat foo.txt
 1477  sort >foo.txt
 1478  cat foo.txt
 1479  # sort will take multiple files and can be concatenated or piped
 1480  # it has all sorts of cool options.  Pun intended
 1481  du -s /usr/share/* | head
 1482  du -s /usr/share/* | sort -nr | head
 1483  # -n sorts numbers, ie 1,2,3 not 1,10,100
 1484  ls -l /usr/bin | head
 1485  ls -l /usr/bin | sort -nr -k 5 
 1486  vim

 1487  sort --key=1,1 --key=2n footoo.txt
 1488  sort -k 3.7nbr -k 3.1nbr -k3.4nbr footoo.txt
 1489  #too cool!

So this lets me sort users and then the value in the 7th column
 1493  sort -t ':' -k /etc/passwd | head
 1494  sort -t ':' -k 7 /etc/passwd | head
 1495  cat > foo.txt
 1496  uniq foo.txt
 1497  # this doesn't work because uniq needs a sorted list
 1498  sort foo.txt | uniq
 1499  # uniq -c output dup lines, -d outp repeated, -f n ignore leading n, -i ignore case, -s n skip(ignore) leading n, -u output unique he default
 1500  sort foo.txt | uniq -c
 1501  cat -A footoo.txt

-A show all non printing characters

 1502  cut -f 3 footoo.txt 
 1503  # returns the third column
 1504  less footoo.txt 
 1505  # file is unchanged
 1506  cut -f 3 footoo.txt | cut -c 7-10
 1507  # so we can pluck relative text
 1508  cut -d ':' -f 1 /etc/passwd | head
 1509  cut -d ':' -f 1 /etc/passwd | head | sort
 1510  cut -d ':' -f 1 /etc/passwd | sort | head 
 1511  less /etc/group
 1512  cut -d ':' -f 1 /etc/group | sort | head
 
1513  # GNU Core Utils
 1514  # these are a good thing
 1515  # coreutils includes expand, turning tabs to spaces and unexpand turning spaces to tabs

 1516  expand footoo.txt | cut -c 23-
 1517  expand footoo.txt | cut -c 23- | sort | uniq
 1518  expand footoo.txt | cut -c 23-27 | sort | uniq
 1519  expand footoo.txt | cut -c 23-27 | sort | uniq -c
 1520  expand footoo.txt | cut -c 23-26 | sort | uniq -c
 1521  # that removed the trailing white space
 1522  # on to paste

 1523  sort -k 3.7nbr -k 3.1nbr -k 3.4nbr footoo.txt > ftbd.txt
 1524  less ftbd.txt 
 1525  cut -f 1,2 ftbd.txt > dv.txt
 1526  head dv.txt 
 1527  cat f* d*
 1529  mkdir textMan
 1530  cp -ap f* d* textMan/ 
 1531  cd textMan/
 1532  ls
 1533  rm -r file-A.zip 
 
look at the contents of all files in a directory
1534  cat *
 1535  ls
 1536  rm foo.txt
 1537  ls
 1538  cat *
 1539  ls
 1540  mv dv.txt distro_version.txt
 1541  mv footoo.txt distros.txt
 1542  mv ftbd.txt distros_by_date.txt
 1543  ls
 1544  cut -f 3 distros_by_date.txt > distros_dates.txt
 1545  cat *

so what does paste do... 

1554  paste distros_dates.txt distro_version.txt 
 1555  less distros_by_date.txt 
 1556  mkdir joins
 1557  cp distros_by_date.txt joins/distros_by_date.txt
 1558  cd joins/
 1559  ls
 1560  cut -f 1,1 distros_by_date.txt > distros_names.txt
 1562  cat *
 1563  cd ..
 1564  ls
 1565  cp distros_dates.txt joins/distros_dates.txt
 1566  cd joins
 1567  ls
 1568  cd textMan/
 1569  cd joins
 1570  ls
 
paste puts things together side by side.

1571  paste distros_dates.txt distros_names.txt >distros-key-Names
 1572  head distros-key-Names 
 1573  cut -f 2,2 distros_by_date.txt > distros_vernums.txt
 1574  du -s /usr/share/* | sort -nr | head
 1575  history | grep PS1
 1583  paste distros_dates.txt distros_vernums.txt > distros_key_vernums.txt
 1584  join distros_key_names.txt distros_key_vernums.tst 
 1585  ls
 
join joins on the key assumed to be in the first column and sorted.


1586  join distros-key-Names.txt distros_key_vernums.tst 
 1587  join distros-key-Names distros_key_vernums.txt 
 1588  cat > file1.txt
 1589  cat > file2.txt
 1590  comm file1.txt file2.txt
 1591  # 3 columns 1:unique to first file 2: unique to second file 3: shard
 1592  comm -12 file1.txt file2.txt
 1593  # above only shows 
 1594  # matches
 1595  ls
 1596  ls > comp1
 1597  touch Changes Changes01
 1598  ls > comp2
 1599  comm comp1 comp2
 1600  diff comp1 comp2
 1601  ls
 1602  diff comp1 comp2
 1603  diff -c comp1 comp2
 1604  diff -u comp1 comp2
 1605  diff -Naur comp1 comp2 >patchfile.txt
 1606  patch < patchfile.txt
 1607  cat comp1
 1608  cat comp1 comp2
 1609  less patchfile.txt 
 1610  #######


 1611  # tr transliteration
 1612  echo "lowercase letters" | tr a-z A-Z
 1613  echo "lowercase letters" | tr [[:lower:]] A
 1614  could feed output for weak passwords
 1615  # could feed output for weak passwords
 1616  tr -d '\r' < dos_file > unix_file
 1617  echo "secret text" | tr a-zA-Z n-za-mN-ZA-M
 1618  # shits letters 13 spaces
 1619  # this is ROT13 encoding
 1620  echo "aaabbbccc" | tr -s ab
 1621  echo "abcabcabc" | tr -s ab


 1622  ##############
 1623  # sed
 1624  # Stream Editor for filtering and transforming text
 1625  echo "front" | sed 's/front/back/'
 1626  # the 's/ is for substatuion
 1627  echo "front" | sed '1s/front/back/'
 1628  echo "front" | sed '1s_front_back_' ; # the delimeter is set by whatever is placed after the command
 1629  echo "front" | sed '2s_front_back_' ; # the number 1 stands for the first line, if we change it to two nothing happens as there is no line two
 1630  ls
 1631  cd ..
 1632  ls dis*
 1633  cat distros.txt
 1634  cat distros.txt | sort -k3
 1635  sed -n '1,5p' distros.txt
 1636  sed -n '/SUSE/!p' distros.txt
 1637  sed -n '/SUSE/p' distros.txt
 1638  # we can uses sed with regex
 1644  sed 's/\([0-9]\{2\}\)\/\([0-9]\{2\}\)\/\([0-9]\{4\}\)$/\3-\1-\2/' distros.txt
 1645  # note the subexprsions are passed onto the second regex as numbers
 1646  echo "aaabbbccc" | sed 's/b/B/'
 1647  echo "aaabbbccc" | sed 's/b/B/g'
 
 1649  sudo apt-get install logo
 1650  cat > foo.txt
 1651  aspell foo.txt
 1652  aspell check foo.txt
 1653  # way cool!
 1654  cat foo.txt
 1655  cat >>foo.txt
 1656  aspell check foo.txt
 1657  ls
 1658  diff foo.txt foo.txt.bak
 1659  diff -u foo.txt foo.txt.bak
 1660  sed -i 's_lazy_laxy_; s_jumped_jimped_' foo.txt
 1661  cat foo.txt
 1662  aspell check foo.txt
 1663  vim
 1664  htmltotext spell.html
 1665  html2text spell.html
 1666  aspell -H check spell.html
 1667  html2text spell.html
 

1668  # split, csplit, sdiff
 1669  man split
 1670  cd notes
 1671  ls
 1672  history > MoreStuff.txt

The one command chapter.

 1004  # make the configured build
 1005  ls
 1006  ./configure
 1007  # congigure made a makefile
 1008  less MakeFile
 1009  ls
 1010  less Makefile
 1011  echo $(PS1)
 1012  make
 1013  # nothing was made the second time
 1014  rm -r getpot.o
 1015  rm -r getopt.o
 1016  make
 1017  ls -a getopt.o diction
 1018  ls -al getopt.o diction
 1019  # Make keeps the main code ahead of the dependancies
 1020  # so if we touch a dependancy
 1021  touch getopt.o
 1022  ls -al getopt.o diction
 1023  make
 1024  # make brings it back inline
 1025  # last but not least we can install it in a well known location on the path
 1026  less INSTALL
 1027  make install
 1028  sudo make instal

On to some print funl
 1029  which diction
 1030  man diction
 1031  man diction | groff -man -w75
 1032  man diction | groff -man -w 75
 1033  man diction | groff -w 75 -man
 1034  man diction | groff -w 50 -man
 1035  man diction | groff -w 50
 1036  cd ..

a side adventure into a note taker

 1037  diction trynotes.txt 
 1038  tn
 1039  alias tn="cat >> trynotes.txt"
 1040  tn
 1041  diction trynotes.txt 
 1042  tn
 1043  diction trynotes.txt 
 1044  diction -h
 1045  diction -s trynotes.txt 
 1046  tn
 1047  diction -s trynotes.txt 
 1048  cat -n trynotes.txt 
 1049  nl trynotes.txt 
 1050  PS1=$(cat shell.txt)
 1051  ls
 1052  mkdir
 1053  mkdir scripts
 1054  cd scripts/
 1055  ls
 1056  vim hello.sh
 1057  ls -l
 1058  chmod 755 hello.sh 
 1059  ls -l
 1060  ./hello.sh 
 1061  ./hello.sh Bobby
 1062  ./hello.sh Bobby Phil
 
1063  # 700 - only owner may execute, 755 - everyone can execute, onlu owner can write

 1064  echo $PATH
 1065  OLDPATH=$PATH
 1066  echo $ OLDPATH
 1067  echo $OLDPATH
 1068  PATH=~\bin:"$PATH"
 1069  echo $PATH
 1070  PATH=$OLDPATH
 1071  echo $PATH
 1072  PATH=~/bin:"$PATH"
 1073  echo $PATH
 1074  cd ..
 1075  mkdir bin
 1076  mv scripts/hello.sh bin/
 1077  cd bin
 1078  ls
 1079  hello.sh
 1080  # sourcing a file means reading it as if input from the keybaord
 1081  # . dot can stand for this command
 1082  # The ~/bin directory is a good place to put scripts intended for personal use. If we write a script that everyone on a system is allowed to use, the traditional location is /usr/local/bin. Scripts intended for use by the system administrator are often located in /usr/local/sbin. In most cases, locally supplied software, whether scripts or compiled programs, should be placed in the /usr/local hierarchy and not in /bin or /usr/bin. These directories are specified by the Linux Filesystem Hierarchy Standard to contain only files supplied and maintained by the Linux distributor.

 1083  # CONFIGURING VIM FOR SCRIPT WRITING

 1084  The vim text editor has many, many configuration settings. Several common options can facilitate script writing.

 1085  :syntax on turns on syntax highlighting. With this setting, different elements of shell syntax will be displayed in different colors when viewing a script. This is helpful for identifying certain kinds of programming errors. It looks cool, too. Note that for this feature to work, you must have a complete version of vim installed, and the file you are editing must have a shebang indicating the file is a shell script. If you have difficulty with :syntax on, try :set syntax=sh instead.

 1086  :set hlsearch turns on the option to highlight search results. Say we search for the word echo. With this option on, each instance of the word will be high- lighted.

 1087  :set tabstop=4 sets the number of columns occupied by a tab character. The default is eight columns. Setting the value to 4 (which is a common prac- tice) allows long lines to fit more easily on the screen.

 1088  :set autoindent turns on the auto indent feature. This causes vim to indent a new line the same amount as the line just typed. This speeds up typing on many kinds of programming constructs. To stop indentation, type CTRL-D.

 1089  These changes can be made permanent by adding these commands (with- out the leading colon characters) to your ~/.vimrc file.
 1090  # end chapter 1

 1091  vim foo.html
 1092  html2text foo.html
 1093  vim foo.html
 1094  html2text foo.html
 1095  PS1=$(cat shell.txt)
 1096  # Multiple variable assignments may be done on a single line:
 1097  a=5 b="a string"
 1098  # curly braces can be used to reduce ambiguity mv $filename ${filename}1
 1099  ls
 1100  cd bin
 1101  ls
 1102  vim sys_rpt.sh
 1103  sys_rpt.sh
 1104  chmod 755 sys_rpt.sh 
 1105  sys_rpt.sh
 1106  sys_rpt.sh | html2text
 1107  # here tokens - backfill into a commnand cat << _EOF_
 1108  vim sys_rpt.sh
 1109  sys_rpt.sh | html2text
 1110  sys_rpt.sh
 1111  # the reason to use a here document is quotes within the doc areignored.
 1112  # cat <<- _EOF_ some text some text some text _EOF_
 1113  # the <<- dash lets us ignore tabs for readability
 1114  # local variables must be declared as local within a ffunciton
 1129  # know that "here" is a name for a tecqunique
 1130  cd bin
 1131  ls
 

1195  # commands have return codes
 1196  # the can be accessed with $?
 1197  echo $?
 1198  # zero means success
 1199  true
 1200  echo $?
 1201  false
 1202  echo $?
 1203  # I hate when they flip those
 1204  # it's not really "success" it's "is error"
 1205  if true; then echo "It's true."; fi
 1206  if false; then echo "It's fals."; fi
 1207  # no return on the fals
 1208  # playing with conditional logic and return values
 1209  if false; true; then echo "It's true."; fi
 1210  # returns a result because it is set to true
 1211  if true; false; then echo "It's true."; fi
 1212  # no return because the true retruned false ;-)
 1213  # there are many tests for file types in if
 1214  # they are thngs like -d file is directory, -e file exists
 1215  # you can test group membership, sticky bits etc
 1216  # using a param in quotes returns an empty string if the value in the param is null.  Saves a lot of errors
 1217  # exit provides a code of zero 0 on exit
 1218  vim take_note.sh 
 1219  # string s can be evaluated.  if a param is not set it is evaluated as false
 1220  if [ $someparam ]; then "true"; else "false" fi; ;
 1221  if [ $someparam ]; then "true"; else "false"; fi
 1222  if [ $someparam ]; then echo "true"; else echo "false"; fi
 1223  if [ $PATH ]; then echo "true"; else echo "false"; fi
 1224  # <> can be used to compare but MUST be escaped with \
 1225  # integers have their own equvilance operators -ne etc
 1226  # modulo works here - good old %, like other arithmetic opperations it (( 5 % 2 ))
 1227  # modern bash has a [[ test ]] block.  It adds the power of regular expressions
 1228  # the == is also supported in [[ test ]]
 1229  #(( )) lets us test integers in a more mathy way
 1230  # AND OR NOT
 1231  # AND test:-a, [[]] or (()) : &&
 1232  # or -o ||
 1233  # not ! !
 1234  # tests are POSIX compliant
 1235  # [[]] (()) are spesific to bash
 1236  # big takeaway
 1237  # bash is available on all platforms
 1238  # the gnu c compiler is available on all platforms
 1239  # you can use the bash shell and tools everywhere you can compile code.
 1240  # HAHAHAHAHHAHAHAHAHAHAHa
 1241  mkdir haha && cd haha
 1242  # on success of the first do the second
 1243  cd ..
 1244  mkdir haha || cd haha
 1245  #mkdir throws an error but the cd still executes - due to or
 1246  # to be clear, if the first or test passes the second is never tried, there is no need
 1247  cd ..
 1248  [ -d haha ] || mkdir haha
 1249  # first test passed, or condition met, second command never tried
 1250  id -u
 1251  # We evaluate the output of the id command. With the -u option, id out- puts the numeric user ID number of the effective user. The superuser is always zero, and every other user is a number greater than zero. Knowing this, we can construct two different here documents, one taking advantage of superuser privileges and the other restricted to the userâ€™s own home directory.
 1252  ls -l
 1253  vim take_note.sh 
 1254  rm -r haha
 1255  read shell.txt
 1256  history | grep -i ps1
 1257  PS1=$(cat shell.txt)
 1258  read
 1259  echo $REPLY
 1260  # This is the read command - it stores its contents in REPLY
 1261  echo -n "Enter Number"
 1262  read
 1263  echo -n "Enter Number "
 1264  # echo -n lets us change the prompt once.  Way cool!
 1265  read v1 v2 v3 v4
 1266  echo $v1
 1267  echo $v2
 1268  read v1 v2 v3 v4
 1269  echo v{1..4}
 1270  echo $v{1..4}
 1271  read v1 v2 v3 v4
 1272  echo $v{1..4}
 1273  read -p "Enter Here > "
 1274  echo $REPLY
 1275  # file_info=$(grep "^$user_name:" $FILE)
 1276  # here we grep a user name from the password file whose location is stored in $FILE
 1277  # This is good and leads us to a read option called IFS.  IFS allows us to parse multiple variables from read.
 1278  # Important! Read can not be piped because it uses variables as output.  Every pipe is actually it's own shell environment that does not pass variables back up to the parent environment.  This means reads variables are lost
 1279  # vim
 1280  vim
 1281  fg %1
 1282  # IFS=":" read user pw uid gid name home shell <<< "$file_info"
 1283  # changs IFS from default to colon.  Doing this on one line will preserver the value of the var
 1284  # the read sets up the variables from the password file
 1285  # the <<< is a "here" string as opposed to the "here" block
 1286  # as mentioned, you can't pipe read
 1287  # here && is used to call a function if an undesired circumstance happens. [[ -z $REPLY ]] && invalid_input
 1288  # it is being used as a very terse if, or if ! in this case
 1289  # while loops - while [commands]; do [commands] done
 1290  # The break command immediately terminates a loop, and program control resumes with the next statement following the loop. The continue command causes the remainder of the loop to be skipped, and pro- gram control resumes with the next iteration of the loop.
 1291  # there are also until loops
 1292  # until [commands]; do [commands] done
 1293  # while read distro version release; do
 1294  done < distros.txt
 1295  # the above example shows a file cated into a while loop.
 1296  # a file can also be piped into a while loop
 1297  # if you pipe into a loop variable state will be lost outside the section of pipe
 1298  # use quotes to turn nulls into empty strings and deal with multiple word file names
 1299  # && can be stacked more than two deep:
 1300  # [[ -d $dir_name ]] && cd $dir_name && rm *
 1301  # instead of debug.print use
 1302  #
 1303  # echo "file deletion complete" >&2
 1304  \
 1305  # >&2 goes to standard error
 1306  echo "error" >&2
 1307  #!/bin/bash -x
 1308  # this gives an blow by blow of the expanded commands being executed
 1309  # we can make the trace output more useful export PS4='$LINENO + '
 1310  # if we want to trace a section set -x # Turn on tracing
 1311  # set +x # Turn off tracing
 1312  # don't forget you can echo out variables
 1313  # case also exists 
 1314  # it checks a word against patterns
 1315  # case word in [pattern [| pattern]...) commands ;;]... esac
 1316  # to deal with upper/lower case in case use the or |. a|A
 1317  # ################
 1318  # Paramters passed in 1-9 can be accessed $1 $2 $3 etc
 1319  # 10 on are $[10] $[11]
 1320  # sorry, tha is ${10} ${11} - this makes more sense
 1321  # $# gives the number of arguments input.
 1322  # if a large number of arguments need to be processed shift will do it
 1323  # shift acts like pop, it also removes one from $# as it pops
 1324  ls
 1325  ls -l
 1326  ls -d
 1327  ls -p
 1328  ls --help
 1329  s
 1330  ls
 1331  whereis bigfile.txt
 1332  whatis bigfile.txt
 1333  file bigfile.txt
 1334  # the command basename removes the path and leaves the base name of a file
 1335  exit
 1336  clear
 1337  history
 1338  PS1="$(cat shell.txt)
 1339  "
 1340  PS1="$(cat shell.txt)"
 1341  clear
 1342  ls
 1343  ls -d
 1344  ls -g
 1345  cd snap
 1346  ls
 1347  ls --help | less
 1348  ls -g
 1349  cd ..
 1350  ls
 1351  ls -g
 1352  ls -l
 1353  stat *
 1354  type stat
 1355  file zzedit.txt
 1356  file -i bigtext.txt
 1357  ls
 1358  file bigfile.txt
 1359  file playground
 1360  clear
 1361  ls
 1362  mkdir params
 1363  cd params
 1364  cat > f1.txt
 1365  ls
 1366  less f1.txt
 1367  cat > f2.txt
 1368  cat > play.sh
 1369  chmod 755 play.sh
 1370  cat f1.txt | play.sh
 1371  cat f1.txt | ./play.sh
 1372  vim play.sh
 1373  cat f1.txt | ./play.sh
 1374  vim play.sh
 1375  cat f1.txt | ./play.sh
 1376  vim play.sh
 1377  cat f1.txt | ./play.sh
 1378  vim play.sh
 1379  cat f1.txt | ./play.sh
 1380  vim play.sh
 1381  cd ..
 1382  vim .bashrc 
 1383  . .bashrc
 1384  vim .bashrc 
 1385  . .bashrc
 1386  file_info
 1387  file_info .bashrc
 1388  clear
 1389  ls
 1390  PS1="$(cat shell.txt)"
 1391  ls
 1392  file_info
 1393  ls | file_info
 1394  echo "dv.txt" | file_info
 1395  file_info dv.txt
 1396  clear
 1397  ls
 1398  cd params/
 1399  ls
 1400  vim play.sh
 1401  cat f1.txt | ./play.sh
 1402  cat fi.txt
 1403  cat f1.txt
 1404  ls
 1405  clear
 1406  ls
 1407  echo bob | ./play.sh
 1408  ./play.sh
 1409  vim play.sh 
 1410  ./play.sh
 1411  vim play.sh 
 1412  ./play.sh
 1413  cat f1.txt | ./play.sh
 1414  cat f1.txt | ./play.sh Haha
 1415  vim play.sh 
 1416  ls
 1417  PS1=$(cat shell.txt)
 1418  clear
 1419  # Two params: $* and $@.
 1420  # $* Expands into the list of positional parameters, starting with 1. When surrounded by double quotes, it expands into a double- quoted string containing all the positional parameters, each separated by the first character of the IFS shell variable (by default a space character).
 1421  # $@ Expands into the list of positional parameters, starting with 1. When surrounded by double quotes, it expands each posi- tional parameter into a separate word surrounded by double quotes.
 1422  ####################
 1423  # so $* renders everything seperated by the ifc delimeter regardlessof quotes
 1424  # <- one parameter for each delimeterr
 1425  # "$*" renderes everything into one param regardless of how it is quoted
 1426  # $@ Exact same as $*
 1427  # "$@" One parameter per quoted input
 1428  # the above can be used for warpper functions where you are passing params thru to another program
 1429  # there is more here, keep thinking
 1430  # i need more clarity around single and double brackets and testing.
 1431  # is this a case of all of single works in double so eveyone uses double all the time?
 1432  clear
 1433  PS1=$(cat shell.txt)
 1434  for i in A B C D; do echo $i; done
 1435  # a quick little for loop
 1436  # i wonder how it works with read...
 1437  for i in {A..D}; do echo $i; done
 1438  ls
 1439  for i in big*.txt; do echo $i; done
 1440  # there is a tool for that
 1441  # there is an api for that
 1442  # don't stop on the how do i do that
 1443  # define the thing and find the thing!
 1444  # i need to firm up single quotes in double quotes
 1445  # echo "$i: '$max_word' ($max_len characters)"
 1446  # If the optional in words portion of the for command is omitted, for defaults to processing the positional parameters. We will modify our longest-word script to use this method:
 1447  # bash also supports the c "for" construct
 1448  for (( i=0; i<5; i=i+1 )); do; echo $i;done
 1449  for (( i=0; i<5; i=i+1 )); do echo $i;done
 1450  # the three expressions in the for
 1451  # initialize, limit and give the logic to run.
 1452  du -sh  | cut -f 1
 1453  du -sh 
 1454  du -sh  | cut -f 1
 1455  # muy importante!
 1456  ##############################
 1457  # I shall rule the universe!
 1458  # No one in the 'verse can stop me!
 1459  ##############################
 1460  # I am a leaf on the wind.
 1461  ##############################
 1462  a="foo"
 1463  echo "$a_file"
 1464  # returns null
 1465  echo "${a}_file"
 1466  # {} can also be used for getting past the 9 param ${10} in a script
 1467  # dealing with null
 1468  foo=
 1469  echo {foo}bar
 1470  echo ${foo}bar
 1471  echo "${foo}bar"
 1472  echo '${foo}bar'
 1473  echo "'${foo}bar'"
 1474  # I love scripting!
 1475  cat foo
 1476  cat $foo
 1477  echo $foo
 1478  clear
 1479  ###########
 1480  # back to the text
 1481  ###########
 1482  echo $foo
 1483  echo ${foo:-"unset!"}
 1484  foo=bar
 1485  echo ${foo:-"unset!"}
 1486  # first returns unset, second returns bar
 1487  # the dash gives a return message, = sets the var
 1488  foo=
 1489  echo $foo
 1490  echo ${foo:="default"}
 1491  echo $foo
 1492  ################
 1493  # we can test for errors
 1494  foo=
 1495  echo ${foo:?"Empty!"}
 1496  echo $? # this gives the return value of the last command
 1497  foo=bar
 1498  echo ${foo:?"Empty!"}
 1499  # bar is return so the return value will be zero
 1500  echo $? # this gives the return value of the last command
 1501  #################
 1502  # we can also reset set vars!
 1503  foo=
 1504  echo ${foo:+"setme!"}
 1505  # nothing happens but if we assign a value to foo
 1506  foo=bar
 1507  echo ${foo:+"setme!"}
 1508  echo $foo
 1509  # note that the reset is on the command, not on the variable itself
 1510  # the variable stays set to bar!
 1511  # So effectively this can be used as a null test
 1512  foo=
 1513  echo ${foo:+"setme!"}
 1514  echo $?
 1515  # re: null test - maybe but not going to take the time
 1516  #######################
 1517  # get your vars!
 1518  ${!*}
 1519  ${!B*}
 1520  echo ${!*}
 1521  echo ${!BASH*}
 1522  echo ${!BASH@}
 1523  for i {A..Z}; do echo "${!$i*}" done 
 1524  for i in {A..Z}; do echo "${!$i*}" done  ;
 1525  for i in {A..Z}; do echo "${!$i*}"; done
 1526  for i in {A..Z}; do echo ${!${i}*}; done
 1527  for i in {A..Z}; do echo "${!${i}*}"; done
 1528  echo ${!A*}
 1529  echo ${!B*}
 1530  for i in {A..Z}; do echo ${!${i}*}; done
 1531  for i in {A..Z}; do echo ${!($i)*}; done
 1532  for i in {A..Z}; do echo ${!(${i})*}; done
 1533  for i in {A..Z}; do echo ${i}; done
 1534  for i in {A..Z}; do echo "${i}"; done
 1535  for i in {A..Z}; do echo {"{i}"*}; done
 1536  for i in {A..Z}; do echo ${!"{i}"*}; done
 1537  for i in {A..Z}; do echo ${!${i}*}; done
 1538  for i in {A..Z}; do echo ${!{i}*}; done
 1539  for i in {A..Z}; do echo ${!${i}*}; done
 1540  echo ${!B*}
 1541  # I am not getting this working - not sure why
 1542  clear
 1543  history | grep -i ps1
 1544  PS1=$(cat shell.txt)
 1545  clear
 1546  ###############3
 1547  # String operators
 1548  ################
 1549  foo="this string is too long"
 1550  echo "'$foo' is ${#foo} long"
 1551  # that gives us a character count
 1552  # substrings
 1553  {foo:10}
 1554  ${foo:10}
 1555  echo ${foo:10}
 1556  # gives back the second half of the sting
 1557  echo ${foo:1}
 1558  echo ${foo:0}
 1559  count starts at zero
 1560  # count starts at zero
 1561  clear
 1562  echo ${foo:10:5}
 1563  foo={A..Z}
 1564  echo $foo
 1565  foo="{A..Z}"
 1566  echo $foo
 1567  echo {A..Z}
 1568  foo=(echo {A..Z})
 1569  echo {A..Z}
 1570  echo $foo
 1571  foo=$(echo {A..Z})
 1572  echo $foo
 1573  foo=$(echo {A..Z}{1..9})
 1574  echo $foo
 1575  echo "'$foo' is ${#foo}"
 1576  echo "'\$foo' is ${#foo}"
 1577  foo=$((echo {A..Z}; echo {1..9}))
 1578  foo=$(echo {A..Z}; echo {1..9})
 1579  echo "'\$foo' is ${#foo}"
 1580  echo $foo
 1581  echo"'${foo:12}'" # Try to get F on
 1582  echo "'${foo:12}'" # Try to get F on
 1583  echo "'${foo:11}'" # Try to get F on
 1584  echo "'${foo:10}'" # Try to get F on
 1585  echo "'${foo:10:11}'" # Try to get F thru K
 1586  # perfect as performed!
 1587  clear
 1588  #############33
 1589  # it is easy to start at the other end
 1590  echo "'${foo:-10}'" # Start @ end of string
 1591  echo "'${foo: -10}'" # Start @ end of string
 1592  # white space is important
 1593  echo "'${foo: -10:2}'" # Start @ end of string
 1594  # the 10 started from the back and the 2 started from the front
 1595  echo "'${foo: -10: -2}'" # Start @ end of string
 1596  echo "'${foo: -10:-2}'" # Start @ end of string
 1597  # negatives on the second value are ignored
 1598  ################
 1599  #
 1600  #################
 1601  # These are build for path manipulation:
 1602  #
 1603  foo=file.txt.zip
 1604  echo ${foo#*.}
 1605  # txt.zip comes back
 1606  echo ${foo##*.}
 1607  # zip comes back
 1608  foo=my.mother.told.me.to.pick.the.best.one
 1609  echo ${foo#*.}
 1610  # cuts off my.
 1611  echo ${foo##*.}
 1612  # returns one - cuts everything else
 1613  ################
 1614  #
 1615  # More like this from the other end
 1616  echo ${foo%*.}
 1617  echo ${foo%.*}
 1618  # removed .one
 1619  echo ${foo%%.*}
 1620  # returned my - removed everything else
 1621  # and we can do pattern find and replace
 1622  foo=JPG.JPG.JPG
 1623  echo ${foo/JPG/jpg} # replaces first occrance
 1624  echo ${foo//JPG/jpg} # replaces all occrance
 1625  echo ${foo/#JPG/jpg} # replaces first occrance
 1626  echo ${foo/%JPG/jpg} # replaces last occrance
 1627  ##############
 1628  # expansions are good because they are fast
 1629  # bonus - you can track execution time with the time command!
 1630  time ls
 1631  time echo {A..Z}{a..z}
 1632  clear
 1633  ###################
 1634  # moving on to math
 1635  # base numbers
 1636  echo $((0xff)) # 0x is hexidecimal
 1637  echo $((088)) # 0 is octal
 1638  echo $((077)) # 0 is octal
 1639  echo $((07777)) # 0 is octal
 1640  echo $((0777)) # 0 is octal
 1641  echo $((037)) # 0 is octal
 1642  echo $((077)) # 0 is octal
 1643  echo $((0377)) # 0 is octal
 1644  echo $((2#111111)) # 2# can be x# where x is the base
 1645  echo $((2#11111111)) # 2# can be x# where x is the base
 1646  ##############
 1647  # Unary Operators
 1648  #
 1649  # an example of modulus
 1650  # !/bin/bash
 1651  # modulo : demonstrate the modulo operator
 1652  # for ((i = 0; i <= 20; i = i + 1)); do
 1653  #         remainder=$((i % 5))
 1654  #         if (( remainder == 0 )); then
 1655  #                  printf "<%d> " $i
 1656  #      else
 1657  # fi done
 1658  # printf "\n"
 1659  # we can assign in arithmetic operators
 1660  foo=
 1661  echo $foo
 1662  if (( foo = 5 )); then echo "true"; fi
 1663  echo $foo
 1664  # returns 5
 1665  foo=
 1666  if (( foo == 5 )); then echo "true"; fi
 1667  # this compares the empty foo to 5 - perhaps the expected result
 1668  # beware the bugs
 1669  # other assignment ops, =, +=, -=, *=, /=, %=, ++, --, ++param - preincrement, --param predecriment
 1670  foo=1
 1671  echo $((foo++))
 1672  echo $foo
 1673  foo=1
 1674  echo $((++foo))
 1675  # already set to 2
 1676  for ((i=0;i<8;++i)); do echo $((1<<i)); done
 1677  # yes, ladies and gentalman, we have bitwise operators as well
 1678  # ~negations, << left bitwise shift, >> Right bitwise shift, & and, | or, ^ XOR
 1679  logic operators within (( )) areas expected< > = <= != == && || ex1:ex2:ex3 ternary operator
 1680  echo 1:1:1
 1681  echo $((1:1:1))
 1682  echo $(( 1:1:1 ))
 1683  echo $(( 1?1:1 ))
 1684  echo $(( 1?1:0 ))
 1685  # 1
 1686  echo $(( 0?1:0 ))
 1687  # 0
 1688  # you can use this to create a toggle
 1689  a=0
 1690  ((a<1?++a:--a))
 1691  echo $a
 1692  # returns 1
 1693  ((a<1?++a:--a))
 1694  echo $a
 1695  # returns zero
 1696  PS1=$(cat shell.txt)
 1697  clear
 1698  # we have done while and for
 1699  # Let's talk until!
 1700  thego=0
 1701  until ((thego<>0)); do ((thego=1)) done
 1702  until ((thego<>0)); do ((thego=1)); done
 1703  PS1=$(cat shell.txt)
 1704  ls
 1705  thego=0
 1706  until (( $thego<>0 )); do (($thego=1)); done
 1707  PS1=$(cat shell.txt)
 1708  thego=0
 1709  until (( $thego!=0 )); do (($thego=1)); done
 1710  PS1=$(cat shell.txt)
 1711  thego=0
 1712  until (( $thego!=0 )); do ((thego=1)); done
 1713  until (( $thego!=0 )); do echo "One go!";  ((thego=1)); done
 1714  thego=0; until (( $thego!=0 )); do echo "One go!";  ((thego=1)); done
 1715  thego=0; until (( $thego<5 )); do echo "Go $thego";  ((++thego)); done
 1716  thego=0; until (( $thego>5 )); do echo "Go $thego";  ((++thego)); done
 1717  thego=0; until (( $thego>5 )); do echo "Go $thego";  ((thego++)); done
 1718  bc
 1719  ls
 1720  mkdir bcfun
 1721  cd bcfun
 1722  cat bc.bc
 1723  cat >bc.bc # this can be read stdin to stdout consumed by bc.bc
 1724  cat >bc.bc
 1725  bc < bc.bc
 1726  bc << "27/3*2"
 1727  quit
 1728  exit
 1729  bc <<< "2+2"
 1730  echo "2+2" | bc
 1731  bc 2+2
 1732  # does not work, expects a file
 1733  # will take a here doc
 1734  bc <<< "2+2"
 1735  # will take a pipe
 1736  echo "2+2" | bc
 1737  # will take a file
 1738  bc bc.bc
 1739  # the file puts it in interactive mode
 1740  bc <<- "2+2"
 1741  quit
 1742  bc <<- EOF
 1743  2+2
 1744  EOF
 1745  # leaving bc
 1746  cd ..
 1747  mkdir arrays
 1748  cd arrays
 1749  ls
 1750  ########################
 1751  # arrays
 1752  #
 1753  a[1]=foo
 1754  echo ${a[1]}
 1755  declare -a a
 1756  type $a
 1757  type ${a}
 1758  whatis ${a}
 1759  whatis {a}
 1760  echo ${a}
 1761  man declare
 1762  declare --help
 1763  declare --help | less
 1764  clear
 1765  a[5]=boo
 1766  ${a}
 1767  echo ${a}
 1768  echo ${a[{1..10}]}
 1769  echo $(a[{1..10}])
 1770  # elements start numbering at 0
 1771  days=(Sun Mon Tue Wed Thu Fri Sat)
 1772  echo $days[1]
 1773  echo ${days[1]}
 1774  d=0; until d>6; do echo ${days[$d]}; d++; done
 1775  PS1=$(cat shell.txt)
 1776  # i need to firm up my use of {} [] ()
 1777  # and "" ''
 1778  clear
 1779  d=0; until $d>6; do echo ${days[$d]}; d++; done
 1780  history | grep -i ps1
 1781  PS1=$(cat shell.txt)
 1782  clear
 1783  # from the begining
 1784  days=(Sun Mon Tue Wed Thu Fri Sat)
 1785  echo ${days[1]}
 1786  d=0; until $d>6; do echo ${days[$d]}; $d++; done
 1787  PS1=$(cat shell.txt)
 1788  # i'm going to move on...
 1789  days=(Sun Mon Tue Wed Thu Fri Sat)
 1790  # can also be explicit
 1791  day=([0]=Sun [1]=Mon [2]=tue)
 1792  echo ${day[1]}
 1793  # for his exampe ...
 1794  stat -c %y "bcfun"/* | cut -c 12-13
 1795  stat -c %y "bcfun/*" | cut -c 12-13
 1796  ls
 1797  stat -c %y bcfun/* | cut -c 12-13
 1798  stat bcfun/*
 1799  animals=("a dog" "a cat" "a fish")
 1800  for i in ${animals[@]}; do echo $i; done
 1801  for i in "${animals[*]}"; do echo $i; done
 1802  for i in "${animals[@]}"; do echo $i; done
 1803  a[100]=foo
 1804  echo ${#a[@]}
 1805  # <- length of array
 1806  echo ${#a[100]}
 1807  # <- length of itme in array
 1808  # finding array elements
 1809  # ${!array[*]} ${!array[@]}
 1810  foo=([2]=a [4]=b [6]=c)
 1811  for i in "${foo[@]}"; do echo $i; done # get contents
 1812  for i in "${!foo[@]}"; do echo $i; done # get elements - !
 1813  foo=(a b c)
 1814  echo ${foo[@]}
 1815  foo+=(d e f)
 1816  echo ${foo[@]}
 1817  # += adds elements at the end of an array
 1818  # sorting can be done by looping thru the array and passing the output to sort
 1819  # a_sorted=($(for i in "${a[@]}"; do echo $i; done | sort))
 1820  foo=(z d g j k e l)
 1821  for i in "${foo[@]}"; do echo $i; done | sort
 1822  as=($(for i in "${foo[@]}"; do echo $i; done | sort))
 1823  echo ${as[@]}
 1824  # to delete an array use unset
 1825  unset foo
 1826  echo ${as[@]}
 1827  echo ${foo[@]}
 1828  # or you can pluck elements
 1829  foo (a b c d e)
 1830  foo=(a b c d e)
 1831  echo ${foo[@]}
 1832  unset 'foo[2]'
 1833  echo ${foo[@]}
 1834  echo ${!foo[@]}
 1835  # actions on the array take place on the zero element, not on the array
 1836  foo=(a b c d e f g)
 1837  foo=
 1838  echo ${foo[@]}
 1839  # no a but the rest intact
 1840  echo ${!foo[@]}
 1841  # placeholder for the now null element also intact
 1842  foo=A
 1843  echo ${foo[@]}
 1844  # now A is in the zero element
 1845  # reexamine this for loop structure for arrays for ((expr1; expr2; expr3))
 1846  history | grep -i ps1
 1847  PS1=$(cat shell.txt)
 1848  clear
 1849  ##########################
 1850  # Exotica
 1851  #
 1852  #########################
 1853  # commands can be grouped in
 1854  # group command { c1; c2; c3; ... } ; and whitespace is important
 1855  # subshell commands (c1; c2; [c3; ...] ))
 1856  foo=5
 1857  $(foo=1)
 1858  echo foo
 1859  echo $foo
 1860  # 5 is returned
 1861  # subshells do let vars pass back
 1862  $(echo foo)
 1863  $(echo $foo)
 1864  (echo $foo)
 1865  clear
 1866  # so can we see into a subshell but not out?
 1867  # scope questions!
 1868  foo=5
 1869  { foo=1; }
 1870  echo $foo
 1871  # returns 1
 1872  # group commands make piping easier
 1873  { ls -l; echo "Listing of foo.txt"; cat foo.txt; } | lpr
 1874  lpr
 1875  { ls -l; echo "Listing of foo.txt"; cat foo.txt; } | less
 1876  # this streams all three commands to less
 1877  # each pipe creates its own subshell
 1878  # process substitution
 1879  # <(list of commnads) - results expressed on stdout
 1880  # >(list of commands) - results recieved from stdin
 1881  # so this doesn't work because read writes to a var REPLY in the subshell
 1882  echo "foo" | read
 1883  echo $REPLY
 1884  # but this will
 1885  read < <(echo "foo") # read takes input from stdout of (cmd)
 1886  echo $REPLY
 1887  # and it works
 1888  # we can actually see the stdout file crated
 1889  echo <(echo "foo")
 1890  # /dev/fd/63
 1891  # here is an example, it works from bottom to top
 1892  # !/bin/bash
 1893  # pro-sub : demo of process substitution
 1894  # while read attr links owner group size date time filename; do
 1895  #        Exotica 425
 1896  # cat <<- EOF
 1897  #                          Filename:   $filename
 1898  #                          Size:       $size
 1899  #                          Owner:      $owner
 1900  #                          Group:      $group
 1901  #                          Modified:   $date $time
 1902  #                          Links:      $links
 1903  #                          Attributes: $attr
 1904  #                    EOF
 1905  #              done < <(ls -l | tail -n +2)
 1906  # the listing grouped by () is "piped" using process substitiution into the while where read takes the next line from the input until returning false at EOF 
 1907  # think more about "here" blocks
 1908  ########################
 1909  #
 1910  ########################
 1911  # Traps
 1912  ########################
 1913  # catch cancel command etc and handle them
 1914  #
 1915  # !/bin/bash
 1916  # trap-demo2 : simple signal handling demo
 1917  # exit_on_signal_SIGINT () {
 1918  #         echo "Script interrupted." 2>&1
 1919  # exit 0 }
 1920  #      Exotica 427
 1921  # exit_on_signal_SIGTERM () {
 1922  #         echo "Script terminated." 2>&1
 1923  # exit 0 }
 1924  # trap exit_on_signal_SIGINT SIGINT
 1925  # trap exit_on_signal_SIGTERM SIGTERM
 1926  # for i in {1..5}; do
 1927  #         echo "Iteration $i of 5"
 1928  # sleep 5 done
 1929  # traps can be used to clean up temp files
 1930  # in naming temp files it is important to realize they can be attacked
 1931  # While the scenario is a bit essoteric it is possible.
 1932  # here are some file naming tips
 1933  # One way to create a non-predictable (but still descriptive) name is to do some- thing like this:
 1934  tempfile=/tmp/$(basename $0).$$.$RANDOM
 1935  This will create a filename consisting of the programâ€™s name, followed by its process ID (PID), followed by a random integer. Note, however, that the $RANDOM shell variable returns a value only in the range of 1 to 32767, which is not a very large range in computer terms, so a single instance of the variable is not sufficient to overcome a determined attacker.
 1936  A better way is to use the mktemp program (not to be confused with the mktemp standard library function) to both name and create the temporary file.
 1937  echo 4+4
 1938  echo ${4+4}
 1939  echo $(4+4)
 1940  echo $((4+4))
 1941  # so (( )) is tokenized to not create a subshell or create a special math subshell
 1942  echo ${ 4+4; }
 1943  echo ${ (4+4); }
 1944  echo ${ (4+4) }
 1945  echo ${ 4+4 }
 1946  bc 4+4
 1947  bc < 4+4
 1948  bc <<< 4+4
 1949  # bc can not take input on stdin but can take a "here" var?
 1950  bc < <(4+4)
 1951  bc < <(echo "4+4")
 1952  man readline
 1953  man READLINE
 1954  # tempfile=$(mktemp /tmp/foobar.$$.XXXXXXXXXX)
 1955  # <- example of using mktemp for temp file creation
 1956  ################
 1957  # he covers async, it uses a wait command and process ids.  Very straight forward
 1958  ###############
 1959  #
 1960  ###############
 1961  # Named pipes
 1962  # #############
 1963  mkfifo pipe1
 1964  ls
 1965  cat >> pipe1
 1966  and we are blocked.
 1967  ls - l > pipe1
 1968  ls -l > pipe1
 1969  type mkfifo
 1970  ls /usr/bin/*
 1971  man true
 1972  man m4
 1973  man make
 1974  ls /usr/bin/*
 1975  arch
 1976  clear
 1977  man arch
 1978  uname
 1979  uname -m
 1980  echo $slack_codes[3]
 1981  echo slack_codes[3]
 1982  echo slack_codes[@]
 1983  echo $slack_codes[@]
 1984  foo=(a b c)
 1985  echo $foo[@]
 1986  echo ${foo[@]}
 1987  echo ${slack_codes[@]}
 1988  echo "${foo[@]}"
 1989  echo "'${foo[@]}'"
 1990  for i in ${foo[@]}; do echo i ; done
 1991  for i in ${foo[@]}; do echo $i ; done
 1992  ########################
 1993  clear
 1994  exit
 1995  cat < pipe1
 1996  exit
 1997  history | grep -i ps1
 1998  PS1=$(cat shell.txt)
 1999  ls
 2000  # I have completed everything!
 2001  # I am the lizard king!
 2002  ls notes/
 2003  history > notes/round3.txt
